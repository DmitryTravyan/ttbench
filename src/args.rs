use std::{ffi::OsString, path::PathBuf};

use clap::Parser;

#[derive(Parser, PartialEq, Eq, Debug)]
#[command(version, about, long_about = "")]
pub struct Cli {
    #[arg(short = 'v', action = clap::ArgAction::Count, global = true, default_value_t = 0)]
    pub verbosity: u8,
    #[arg(long = "config", global = true)]
    pub config: Option<PathBuf>,
    #[arg(
        short = 'i', 
        long = "initialize",
        action = clap::ArgAction::SetTrue,
        help = "Required to invoke initialization mode.",
        global = true
    )]
    pub init: bool,
    #[arg(
        short = 't',
        long = "transactions",
        help = "Number of transactions each connection. Default is 100.",
        global = true
    )]
    pub transactions: Option<u64>,
    #[arg(
        short = 'T',
        long = "time",
        help = "Run the test for this many seconds, rather than a fixed number \
            of transactions per client. -t and -T are mutually exclusive.",
        global = true,
        default_value_t = 1
    )]
    pub time: u64,
    #[arg(
        short = 'S',
        long = "scale",
        help = "Multiply the number of tuples generated by the scale factor. \
            For example, -s 100 will create 10,000,000 tuples in the 
            ttbench_accounts table. Default is 1. When the scale is 20,000 or \
            larger, the columns used to hold account identifiers (aid columns) \
            will switch to using larger integers (bigint), \
            in order to be big enough to hold the range of account identifiers.",
        default_value_t = 1
    )]
    pub scale: u64,
    // TODO Help
    #[arg(short = 'I', long = "init-steps")]
    pub init_steps: Option<String>,
    #[arg(
        short = 'c',
        long = "connections",
        help = "Number of connections openned, that is, number of concurrent \
            IPROTO sessions. Default is 2.",
        default_value_t = 2
    )]
    pub connections: u64,
    #[arg(
        short = 'j',
        long = "jobs",
        help = "Number of worker threads within ttbench. Using more than one \
            thread can be helpful on multi-CPU machines. Connections are distributed \
            as evenly as possible among available jobs. Default is 100.",
        default_value_t = 100,
    )]
    pub jobs: u64,
    #[arg(
        long = "keep-history",
        action = clap::ArgAction::SetTrue,
        help = "Keep 'ttbench_history' table then 'Drop' step called.",
        global = true,
    )]
    pub keep_history: bool,
}

pub fn init<A, T>(args: A) -> Cli
where
    A: IntoIterator<Item = T>,
    T: Into<OsString> + Clone,
{
    Cli::parse_from(args)
}

#[cfg(test)]
mod test {
    use std::{path::PathBuf, str::FromStr};

    use clap::Parser;

    use super::{init, Cli};

    #[test]
    fn test_run_cmd() {
        let args: Cli = Parser::parse_from(["ttbench", "-vvvv", "run"]);

        assert_eq!(
            args,
            Cli {
                    scale: 1,
                    init_steps: None,
                    connections: 2,
                    jobs: 100,
                verbosity: 4,
                config: None,
                init: false,
                transactions: None,
                time: 60,
                keep_history: false
            }
        );

        let args: Cli = Parser::parse_from([
            "ttbench",
            "run",
            "-vvvv",
            "-S",
            "200",
            "--config",
            "/tmp/config.toml",
            "-I",
            "dtpGv",
            "-i",
            "--keep-history",
            "--c",
            "10",
            "-j",
            "1000",
        ]);

        assert_eq!(
            args,
            Cli {
                    scale: 200,
                    init_steps: Some("dtpGv".into()),
                    connections: 2,
                    jobs: 1000,
                verbosity: 4,
                config: Some(PathBuf::from_str("/tmp/config.toml").unwrap()),
                init: true,
                transactions: None,
                time: 60,
                keep_history: false
            }
        );

        let args: Cli = Parser::parse_from(["ttbench", "run"]);

        assert_eq!(
            args,
            Cli {
                    scale: 1,
                    init_steps: None,
                    connections: 2,
                    jobs: 100,
                verbosity: 0,
                config: None,
                init: false,
                transactions: None,
                time: 60,
                keep_history: false
            }
        );
    }

    #[test]
    fn test_init() {
        let cli = init(["ttbench", "-vvvv", "run"]);

        assert_eq!(
            cli,
            Cli {
                    scale: 1,
                    init_steps: None,
                    connections: 2,
                    jobs: 100,
                verbosity: 4,
                config: None,
                init: false,
                transactions: None,
                time: 60,
                keep_history: false
            }
        );
    }
}
